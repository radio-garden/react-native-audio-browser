///
/// NativeBrowserConfiguration.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import Foundation
import NitroModules

/**
 * Represents an instance of `NativeBrowserConfiguration`, backed by a C++ struct.
 */
public typealias NativeBrowserConfiguration = margelo.nitro.audiobrowser.NativeBrowserConfiguration

public extension NativeBrowserConfiguration {
  private typealias bridge = margelo.nitro.audiobrowser.bridge.swift

  /**
   * Create a new instance of `NativeBrowserConfiguration`.
   */
  init(path: String?, request: TransformableRequestConfig?, media: MediaRequestConfig?, artwork: MediaRequestConfig?, routes: [NativeRouteEntry]?, singleTrack: Bool?, androidControllerOfflineError: Bool?, carPlayUpNextButton: Bool?, carPlayNowPlayingButtons: [CarPlayNowPlayingButton]?, formatNavigationError: ((_ params: FormatNavigationErrorParams) -> Promise<FormattedNavigationError?>)?) {
    self.init({ () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = path {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_TransformableRequestConfig_ in
      if let __unwrappedValue = request {
        return bridge.create_std__optional_TransformableRequestConfig_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_MediaRequestConfig_ in
      if let __unwrappedValue = media {
        return bridge.create_std__optional_MediaRequestConfig_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_MediaRequestConfig_ in
      if let __unwrappedValue = artwork {
        return bridge.create_std__optional_MediaRequestConfig_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__vector_NativeRouteEntry__ in
      if let __unwrappedValue = routes {
        return bridge.create_std__optional_std__vector_NativeRouteEntry__({ () -> bridge.std__vector_NativeRouteEntry_ in
          var __vector = bridge.create_std__vector_NativeRouteEntry_(__unwrappedValue.count)
          for __item in __unwrappedValue {
            __vector.push_back(__item)
          }
          return __vector
        }())
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = singleTrack {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = androidControllerOfflineError {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = carPlayUpNextButton {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__vector_CarPlayNowPlayingButton__ in
      if let __unwrappedValue = carPlayNowPlayingButtons {
        return bridge.create_std__optional_std__vector_CarPlayNowPlayingButton__({ () -> bridge.std__vector_CarPlayNowPlayingButton_ in
          var __vector = bridge.create_std__vector_CarPlayNowPlayingButton_(__unwrappedValue.count)
          for __item in __unwrappedValue {
            __vector.push_back(__item)
          }
          return __vector
        }())
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__function_std__shared_ptr_Promise_std__optional_FormattedNavigationError____const_FormatNavigationErrorParams_____params______ in
      if let __unwrappedValue = formatNavigationError {
        return bridge.create_std__optional_std__function_std__shared_ptr_Promise_std__optional_FormattedNavigationError____const_FormatNavigationErrorParams_____params______({ () -> bridge.Func_std__shared_ptr_Promise_std__optional_FormattedNavigationError____FormatNavigationErrorParams in
          let __closureWrapper = Func_std__shared_ptr_Promise_std__optional_FormattedNavigationError____FormatNavigationErrorParams(__unwrappedValue)
          return bridge.create_Func_std__shared_ptr_Promise_std__optional_FormattedNavigationError____FormatNavigationErrorParams(__closureWrapper.toUnsafe())
        }())
      } else {
        return .init()
      }
    }())
  }

  var path: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__path) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__path)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__path = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var request: TransformableRequestConfig? {
    @inline(__always)
    get {
      return self.__request.value
    }
    @inline(__always)
    set {
      self.__request = { () -> bridge.std__optional_TransformableRequestConfig_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_TransformableRequestConfig_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var media: MediaRequestConfig? {
    @inline(__always)
    get {
      return self.__media.value
    }
    @inline(__always)
    set {
      self.__media = { () -> bridge.std__optional_MediaRequestConfig_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_MediaRequestConfig_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var artwork: MediaRequestConfig? {
    @inline(__always)
    get {
      return self.__artwork.value
    }
    @inline(__always)
    set {
      self.__artwork = { () -> bridge.std__optional_MediaRequestConfig_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_MediaRequestConfig_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var routes: [NativeRouteEntry]? {
    @inline(__always)
    get {
      return { () -> [NativeRouteEntry]? in
        if bridge.has_value_std__optional_std__vector_NativeRouteEntry__(self.__routes) {
          let __unwrapped = bridge.get_std__optional_std__vector_NativeRouteEntry__(self.__routes)
          return __unwrapped.map({ __item in __item })
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__routes = { () -> bridge.std__optional_std__vector_NativeRouteEntry__ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__vector_NativeRouteEntry__({ () -> bridge.std__vector_NativeRouteEntry_ in
            var __vector = bridge.create_std__vector_NativeRouteEntry_(__unwrappedValue.count)
            for __item in __unwrappedValue {
              __vector.push_back(__item)
            }
            return __vector
          }())
        } else {
          return .init()
        }
      }()
    }
  }
  
  var singleTrack: Bool? {
    @inline(__always)
    get {
      return { () -> Bool? in
        if bridge.has_value_std__optional_bool_(self.__singleTrack) {
          let __unwrapped = bridge.get_std__optional_bool_(self.__singleTrack)
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__singleTrack = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var androidControllerOfflineError: Bool? {
    @inline(__always)
    get {
      return { () -> Bool? in
        if bridge.has_value_std__optional_bool_(self.__androidControllerOfflineError) {
          let __unwrapped = bridge.get_std__optional_bool_(self.__androidControllerOfflineError)
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__androidControllerOfflineError = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var carPlayUpNextButton: Bool? {
    @inline(__always)
    get {
      return { () -> Bool? in
        if bridge.has_value_std__optional_bool_(self.__carPlayUpNextButton) {
          let __unwrapped = bridge.get_std__optional_bool_(self.__carPlayUpNextButton)
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__carPlayUpNextButton = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var carPlayNowPlayingButtons: [CarPlayNowPlayingButton]? {
    @inline(__always)
    get {
      return { () -> [CarPlayNowPlayingButton]? in
        if bridge.has_value_std__optional_std__vector_CarPlayNowPlayingButton__(self.__carPlayNowPlayingButtons) {
          let __unwrapped = bridge.get_std__optional_std__vector_CarPlayNowPlayingButton__(self.__carPlayNowPlayingButtons)
          return __unwrapped.map({ __item in __item })
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__carPlayNowPlayingButtons = { () -> bridge.std__optional_std__vector_CarPlayNowPlayingButton__ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__vector_CarPlayNowPlayingButton__({ () -> bridge.std__vector_CarPlayNowPlayingButton_ in
            var __vector = bridge.create_std__vector_CarPlayNowPlayingButton_(__unwrappedValue.count)
            for __item in __unwrappedValue {
              __vector.push_back(__item)
            }
            return __vector
          }())
        } else {
          return .init()
        }
      }()
    }
  }
  
  var formatNavigationError: ((_ params: FormatNavigationErrorParams) -> Promise<FormattedNavigationError?>)? {
    @inline(__always)
    get {
      return { () -> ((_ params: FormatNavigationErrorParams) -> Promise<FormattedNavigationError?>)? in
        if bridge.has_value_std__optional_std__function_std__shared_ptr_Promise_std__optional_FormattedNavigationError____const_FormatNavigationErrorParams_____params______(self.__formatNavigationError) {
          let __unwrapped = bridge.get_std__optional_std__function_std__shared_ptr_Promise_std__optional_FormattedNavigationError____const_FormatNavigationErrorParams_____params______(self.__formatNavigationError)
          return { () -> (FormatNavigationErrorParams) -> Promise<FormattedNavigationError?> in
            let __wrappedFunction = bridge.wrap_Func_std__shared_ptr_Promise_std__optional_FormattedNavigationError____FormatNavigationErrorParams(__unwrapped)
            return { (__params: FormatNavigationErrorParams) -> Promise<FormattedNavigationError?> in
              let __result = __wrappedFunction.call(__params)
              return { () -> Promise<FormattedNavigationError?> in
                let __promise = Promise<FormattedNavigationError?>()
                let __resolver = { (__result: FormattedNavigationError?) in
                  __promise.resolve(withResult: __result)
                }
                let __rejecter = { (__error: Error) in
                  __promise.reject(withError: __error)
                }
                let __resolverCpp = { () -> bridge.Func_void_std__optional_FormattedNavigationError_ in
                  let __closureWrapper = Func_void_std__optional_FormattedNavigationError_(__resolver)
                  return bridge.create_Func_void_std__optional_FormattedNavigationError_(__closureWrapper.toUnsafe())
                }()
                let __rejecterCpp = { () -> bridge.Func_void_std__exception_ptr in
                  let __closureWrapper = Func_void_std__exception_ptr(__rejecter)
                  return bridge.create_Func_void_std__exception_ptr(__closureWrapper.toUnsafe())
                }()
                let __promiseHolder = bridge.wrap_std__shared_ptr_Promise_std__optional_FormattedNavigationError___(__result)
                __promiseHolder.addOnResolvedListener(__resolverCpp)
                __promiseHolder.addOnRejectedListener(__rejecterCpp)
                return __promise
              }()
            }
          }()
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__formatNavigationError = { () -> bridge.std__optional_std__function_std__shared_ptr_Promise_std__optional_FormattedNavigationError____const_FormatNavigationErrorParams_____params______ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__function_std__shared_ptr_Promise_std__optional_FormattedNavigationError____const_FormatNavigationErrorParams_____params______({ () -> bridge.Func_std__shared_ptr_Promise_std__optional_FormattedNavigationError____FormatNavigationErrorParams in
            let __closureWrapper = Func_std__shared_ptr_Promise_std__optional_FormattedNavigationError____FormatNavigationErrorParams(__unwrappedValue)
            return bridge.create_Func_std__shared_ptr_Promise_std__optional_FormattedNavigationError____FormatNavigationErrorParams(__closureWrapper.toUnsafe())
          }())
        } else {
          return .init()
        }
      }()
    }
  }
}
