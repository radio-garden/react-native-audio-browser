///
/// HybridAudioBrowserSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include "HybridAudioBrowserSpec.hpp"

// Forward declaration of `HybridAudioBrowserSpec_cxx` to properly resolve imports.
namespace AudioBrowser { class HybridAudioBrowserSpec_cxx; }

// Forward declaration of `Track` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct Track; }
// Forward declaration of `ImageSource` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct ImageSource; }
// Forward declaration of `HttpMethod` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class HttpMethod; }
// Forward declaration of `TrackStyle` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class TrackStyle; }
// Forward declaration of `ResolvedTrack` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct ResolvedTrack; }
// Forward declaration of `NavigationErrorEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct NavigationErrorEvent; }
// Forward declaration of `NavigationError` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct NavigationError; }
// Forward declaration of `NavigationErrorType` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class NavigationErrorType; }
// Forward declaration of `FormattedNavigationError` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct FormattedNavigationError; }
// Forward declaration of `TransformableRequestConfig` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct TransformableRequestConfig; }
// Forward declaration of `RequestConfig` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RequestConfig; }
// Forward declaration of `MediaRequestConfig` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct MediaRequestConfig; }
// Forward declaration of `ArtworkRequestConfig` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct ArtworkRequestConfig; }
// Forward declaration of `MediaTransformParams` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct MediaTransformParams; }
// Forward declaration of `ImageContext` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct ImageContext; }
// Forward declaration of `ImageQueryParams` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct ImageQueryParams; }
// Forward declaration of `NativeRouteEntry` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct NativeRouteEntry; }
// Forward declaration of `BrowseError` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct BrowseError; }
// Forward declaration of `BrowserSourceCallbackParam` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct BrowserSourceCallbackParam; }
// Forward declaration of `SearchParams` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct SearchParams; }
// Forward declaration of `SearchMode` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class SearchMode; }
// Forward declaration of `CarPlayNowPlayingButton` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class CarPlayNowPlayingButton; }
// Forward declaration of `FormatNavigationErrorParams` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct FormatNavigationErrorParams; }
// Forward declaration of `AudioMetadataReceivedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct AudioMetadataReceivedEvent; }
// Forward declaration of `AudioMetadata` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct AudioMetadata; }
// Forward declaration of `AudioCommonMetadataReceivedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct AudioCommonMetadataReceivedEvent; }
// Forward declaration of `PlaybackMetadata` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackMetadata; }
// Forward declaration of `PlaybackActiveTrackChangedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackActiveTrackChangedEvent; }
// Forward declaration of `PlaybackErrorEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackErrorEvent; }
// Forward declaration of `PlaybackError` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackError; }
// Forward declaration of `PlaybackPlayWhenReadyChangedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackPlayWhenReadyChangedEvent; }
// Forward declaration of `PlayingState` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlayingState; }
// Forward declaration of `PlaybackProgressUpdatedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackProgressUpdatedEvent; }
// Forward declaration of `PlaybackQueueEndedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackQueueEndedEvent; }
// Forward declaration of `RepeatModeChangedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RepeatModeChangedEvent; }
// Forward declaration of `RepeatMode` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class RepeatMode; }
// Forward declaration of `SleepTimerTime` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct SleepTimerTime; }
// Forward declaration of `SleepTimerEndOfTrack` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct SleepTimerEndOfTrack; }
// Forward declaration of `Playback` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct Playback; }
// Forward declaration of `PlaybackState` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class PlaybackState; }
// Forward declaration of `RemoteJumpBackwardEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RemoteJumpBackwardEvent; }
// Forward declaration of `RemoteJumpForwardEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RemoteJumpForwardEvent; }
// Forward declaration of `RemotePlayIdEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RemotePlayIdEvent; }
// Forward declaration of `RemotePlaySearchEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RemotePlaySearchEvent; }
// Forward declaration of `RemoteSeekEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RemoteSeekEvent; }
// Forward declaration of `RemoteSetRatingEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RemoteSetRatingEvent; }
// Forward declaration of `HeartRating` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct HeartRating; }
// Forward declaration of `ThumbsRating` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct ThumbsRating; }
// Forward declaration of `StarRating` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct StarRating; }
// Forward declaration of `PercentageRating` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PercentageRating; }
// Forward declaration of `RemoteSkipEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RemoteSkipEvent; }
// Forward declaration of `Options` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct Options; }
// Forward declaration of `AndroidOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct AndroidOptions; }
// Forward declaration of `AppKilledPlaybackBehavior` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class AppKilledPlaybackBehavior; }
// Forward declaration of `RatingType` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class RatingType; }
// Forward declaration of `NotificationButtonLayout` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct NotificationButtonLayout; }
// Forward declaration of `NotificationButton` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class NotificationButton; }
// Forward declaration of `IOSOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct IOSOptions; }
// Forward declaration of `FeedbackOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct FeedbackOptions; }
// Forward declaration of `PlayerCapabilities` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlayerCapabilities; }
// Forward declaration of `FavoriteChangedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct FavoriteChangedEvent; }
// Forward declaration of `NowPlayingMetadata` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct NowPlayingMetadata; }
// Forward declaration of `EqualizerSettings` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct EqualizerSettings; }
// Forward declaration of `BatteryWarningPendingChangedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct BatteryWarningPendingChangedEvent; }
// Forward declaration of `BatteryOptimizationStatusChangedEvent` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct BatteryOptimizationStatusChangedEvent; }
// Forward declaration of `BatteryOptimizationStatus` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class BatteryOptimizationStatus; }
// Forward declaration of `PartialSetupPlayerOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PartialSetupPlayerOptions; }
// Forward declaration of `PartialAndroidSetupPlayerOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PartialAndroidSetupPlayerOptions; }
// Forward declaration of `AndroidAudioOffloadSettings` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct AndroidAudioOffloadSettings; }
// Forward declaration of `RetryConfig` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct RetryConfig; }
// Forward declaration of `AndroidAudioContentType` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class AndroidAudioContentType; }
// Forward declaration of `AndroidPlayerWakeMode` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class AndroidPlayerWakeMode; }
// Forward declaration of `PartialIOSSetupPlayerOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PartialIOSSetupPlayerOptions; }
// Forward declaration of `IOSCategory` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class IOSCategory; }
// Forward declaration of `IOSCategoryMode` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class IOSCategoryMode; }
// Forward declaration of `IOSCategoryOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class IOSCategoryOptions; }
// Forward declaration of `IOSCategoryPolicy` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class IOSCategoryPolicy; }
// Forward declaration of `NativeUpdateOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct NativeUpdateOptions; }
// Forward declaration of `NitroAndroidUpdateOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct NitroAndroidUpdateOptions; }
// Forward declaration of `IOSUpdateOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct IOSUpdateOptions; }
// Forward declaration of `AndroidUpdateOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct AndroidUpdateOptions; }
// Forward declaration of `NowPlayingUpdate` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct NowPlayingUpdate; }

#include <string>
#include <optional>
#include "Track.hpp"
#include <vector>
#include "ImageSource.hpp"
#include "HttpMethod.hpp"
#include <unordered_map>
#include "TrackStyle.hpp"
#include <functional>
#include "ResolvedTrack.hpp"
#include "NavigationErrorEvent.hpp"
#include "NavigationError.hpp"
#include "NavigationErrorType.hpp"
#include "FormattedNavigationError.hpp"
#include "TransformableRequestConfig.hpp"
#include "RequestConfig.hpp"
#include <NitroModules/Promise.hpp>
#include "MediaRequestConfig.hpp"
#include "ArtworkRequestConfig.hpp"
#include "MediaTransformParams.hpp"
#include "ImageContext.hpp"
#include "ImageQueryParams.hpp"
#include "NativeRouteEntry.hpp"
#include "BrowseError.hpp"
#include <variant>
#include "BrowserSourceCallbackParam.hpp"
#include "SearchParams.hpp"
#include "SearchMode.hpp"
#include "CarPlayNowPlayingButton.hpp"
#include "FormatNavigationErrorParams.hpp"
#include "AudioMetadataReceivedEvent.hpp"
#include "AudioMetadata.hpp"
#include "AudioCommonMetadataReceivedEvent.hpp"
#include "PlaybackMetadata.hpp"
#include "PlaybackActiveTrackChangedEvent.hpp"
#include "PlaybackErrorEvent.hpp"
#include "PlaybackError.hpp"
#include "PlaybackPlayWhenReadyChangedEvent.hpp"
#include "PlayingState.hpp"
#include "PlaybackProgressUpdatedEvent.hpp"
#include "PlaybackQueueEndedEvent.hpp"
#include "RepeatModeChangedEvent.hpp"
#include "RepeatMode.hpp"
#include <NitroModules/Null.hpp>
#include "SleepTimerTime.hpp"
#include "SleepTimerEndOfTrack.hpp"
#include "Playback.hpp"
#include "PlaybackState.hpp"
#include "RemoteJumpBackwardEvent.hpp"
#include "RemoteJumpForwardEvent.hpp"
#include "RemotePlayIdEvent.hpp"
#include "RemotePlaySearchEvent.hpp"
#include "RemoteSeekEvent.hpp"
#include "RemoteSetRatingEvent.hpp"
#include "HeartRating.hpp"
#include "ThumbsRating.hpp"
#include "StarRating.hpp"
#include "PercentageRating.hpp"
#include "RemoteSkipEvent.hpp"
#include "Options.hpp"
#include "AndroidOptions.hpp"
#include "AppKilledPlaybackBehavior.hpp"
#include "RatingType.hpp"
#include "NotificationButtonLayout.hpp"
#include "NotificationButton.hpp"
#include "IOSOptions.hpp"
#include "FeedbackOptions.hpp"
#include "PlayerCapabilities.hpp"
#include "FavoriteChangedEvent.hpp"
#include "NowPlayingMetadata.hpp"
#include "EqualizerSettings.hpp"
#include "BatteryWarningPendingChangedEvent.hpp"
#include "BatteryOptimizationStatusChangedEvent.hpp"
#include "BatteryOptimizationStatus.hpp"
#include "PartialSetupPlayerOptions.hpp"
#include "PartialAndroidSetupPlayerOptions.hpp"
#include "AndroidAudioOffloadSettings.hpp"
#include "RetryConfig.hpp"
#include "AndroidAudioContentType.hpp"
#include "AndroidPlayerWakeMode.hpp"
#include "PartialIOSSetupPlayerOptions.hpp"
#include "IOSCategory.hpp"
#include "IOSCategoryMode.hpp"
#include "IOSCategoryOptions.hpp"
#include "IOSCategoryPolicy.hpp"
#include "NativeUpdateOptions.hpp"
#include "NitroAndroidUpdateOptions.hpp"
#include "IOSUpdateOptions.hpp"
#include "AndroidUpdateOptions.hpp"
#include "NowPlayingUpdate.hpp"

#include "AudioBrowser-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::audiobrowser {

  /**
   * The C++ part of HybridAudioBrowserSpec_cxx.swift.
   *
   * HybridAudioBrowserSpecSwift (C++) accesses HybridAudioBrowserSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridAudioBrowserSpec_cxx can directly inherit from the C++ class HybridAudioBrowserSpec
   * to simplify the whole structure and memory management.
   */
  class HybridAudioBrowserSpecSwift: public virtual HybridAudioBrowserSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridAudioBrowserSpecSwift(const AudioBrowser::HybridAudioBrowserSpec_cxx& swiftPart):
      HybridObject(HybridAudioBrowserSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline AudioBrowser::HybridAudioBrowserSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }
    void dispose() noexcept override {
      _swiftPart.dispose();
    }
    std::string toString() override {
      return _swiftPart.toString();
    }

  public:
    // Properties
    inline std::optional<std::string> getPath() noexcept override {
      auto __result = _swiftPart.getPath();
      return __result;
    }
    inline void setPath(const std::optional<std::string>& path) noexcept override {
      _swiftPart.setPath(path);
    }
    inline std::optional<std::vector<Track>> getTabs() noexcept override {
      auto __result = _swiftPart.getTabs();
      return __result;
    }
    inline void setTabs(const std::optional<std::vector<Track>>& tabs) noexcept override {
      _swiftPart.setTabs(tabs);
    }
    inline std::function<void(const std::string& /* path */)> getOnPathChanged() noexcept override {
      auto __result = _swiftPart.getOnPathChanged();
      return __result;
    }
    inline void setOnPathChanged(const std::function<void(const std::string& /* path */)>& onPathChanged) noexcept override {
      _swiftPart.setOnPathChanged(onPathChanged);
    }
    inline std::function<void(const std::optional<ResolvedTrack>& /* content */)> getOnContentChanged() noexcept override {
      auto __result = _swiftPart.getOnContentChanged();
      return __result;
    }
    inline void setOnContentChanged(const std::function<void(const std::optional<ResolvedTrack>& /* content */)>& onContentChanged) noexcept override {
      _swiftPart.setOnContentChanged(onContentChanged);
    }
    inline std::function<void(const std::vector<Track>& /* tabs */)> getOnTabsChanged() noexcept override {
      auto __result = _swiftPart.getOnTabsChanged();
      return __result;
    }
    inline void setOnTabsChanged(const std::function<void(const std::vector<Track>& /* tabs */)>& onTabsChanged) noexcept override {
      _swiftPart.setOnTabsChanged(onTabsChanged);
    }
    inline std::function<void(const NavigationErrorEvent& /* data */)> getOnNavigationError() noexcept override {
      auto __result = _swiftPart.getOnNavigationError();
      return __result;
    }
    inline void setOnNavigationError(const std::function<void(const NavigationErrorEvent& /* data */)>& onNavigationError) noexcept override {
      _swiftPart.setOnNavigationError(onNavigationError);
    }
    inline std::function<void(const std::optional<FormattedNavigationError>& /* formattedError */)> getOnFormattedNavigationError() noexcept override {
      auto __result = _swiftPart.getOnFormattedNavigationError();
      return __result;
    }
    inline void setOnFormattedNavigationError(const std::function<void(const std::optional<FormattedNavigationError>& /* formattedError */)>& onFormattedNavigationError) noexcept override {
      _swiftPart.setOnFormattedNavigationError(onFormattedNavigationError);
    }
    inline NativeBrowserConfiguration getConfiguration() noexcept override {
      return _swiftPart.getConfiguration();
    }
    inline void setConfiguration(const NativeBrowserConfiguration& configuration) noexcept override {
      _swiftPart.setConfiguration(std::forward<decltype(configuration)>(configuration));
    }
    inline std::function<void(const AudioMetadataReceivedEvent& /* event */)> getOnMetadataChapterReceived() noexcept override {
      auto __result = _swiftPart.getOnMetadataChapterReceived();
      return __result;
    }
    inline void setOnMetadataChapterReceived(const std::function<void(const AudioMetadataReceivedEvent& /* event */)>& onMetadataChapterReceived) noexcept override {
      _swiftPart.setOnMetadataChapterReceived(onMetadataChapterReceived);
    }
    inline std::function<void(const AudioCommonMetadataReceivedEvent& /* event */)> getOnMetadataCommonReceived() noexcept override {
      auto __result = _swiftPart.getOnMetadataCommonReceived();
      return __result;
    }
    inline void setOnMetadataCommonReceived(const std::function<void(const AudioCommonMetadataReceivedEvent& /* event */)>& onMetadataCommonReceived) noexcept override {
      _swiftPart.setOnMetadataCommonReceived(onMetadataCommonReceived);
    }
    inline std::function<void(const AudioMetadataReceivedEvent& /* event */)> getOnMetadataTimedReceived() noexcept override {
      auto __result = _swiftPart.getOnMetadataTimedReceived();
      return __result;
    }
    inline void setOnMetadataTimedReceived(const std::function<void(const AudioMetadataReceivedEvent& /* event */)>& onMetadataTimedReceived) noexcept override {
      _swiftPart.setOnMetadataTimedReceived(onMetadataTimedReceived);
    }
    inline std::function<void(const PlaybackMetadata& /* data */)> getOnPlaybackMetadata() noexcept override {
      auto __result = _swiftPart.getOnPlaybackMetadata();
      return __result;
    }
    inline void setOnPlaybackMetadata(const std::function<void(const PlaybackMetadata& /* data */)>& onPlaybackMetadata) noexcept override {
      _swiftPart.setOnPlaybackMetadata(onPlaybackMetadata);
    }
    inline std::function<void(const PlaybackActiveTrackChangedEvent& /* data */)> getOnPlaybackActiveTrackChanged() noexcept override {
      auto __result = _swiftPart.getOnPlaybackActiveTrackChanged();
      return __result;
    }
    inline void setOnPlaybackActiveTrackChanged(const std::function<void(const PlaybackActiveTrackChangedEvent& /* data */)>& onPlaybackActiveTrackChanged) noexcept override {
      _swiftPart.setOnPlaybackActiveTrackChanged(onPlaybackActiveTrackChanged);
    }
    inline std::function<void(const PlaybackErrorEvent& /* data */)> getOnPlaybackError() noexcept override {
      auto __result = _swiftPart.getOnPlaybackError();
      return __result;
    }
    inline void setOnPlaybackError(const std::function<void(const PlaybackErrorEvent& /* data */)>& onPlaybackError) noexcept override {
      _swiftPart.setOnPlaybackError(onPlaybackError);
    }
    inline std::function<void(const PlaybackPlayWhenReadyChangedEvent& /* data */)> getOnPlaybackPlayWhenReadyChanged() noexcept override {
      auto __result = _swiftPart.getOnPlaybackPlayWhenReadyChanged();
      return __result;
    }
    inline void setOnPlaybackPlayWhenReadyChanged(const std::function<void(const PlaybackPlayWhenReadyChangedEvent& /* data */)>& onPlaybackPlayWhenReadyChanged) noexcept override {
      _swiftPart.setOnPlaybackPlayWhenReadyChanged(onPlaybackPlayWhenReadyChanged);
    }
    inline std::function<void(const PlayingState& /* data */)> getOnPlaybackPlayingState() noexcept override {
      auto __result = _swiftPart.getOnPlaybackPlayingState();
      return __result;
    }
    inline void setOnPlaybackPlayingState(const std::function<void(const PlayingState& /* data */)>& onPlaybackPlayingState) noexcept override {
      _swiftPart.setOnPlaybackPlayingState(onPlaybackPlayingState);
    }
    inline std::function<void(const PlaybackProgressUpdatedEvent& /* data */)> getOnPlaybackProgressUpdated() noexcept override {
      auto __result = _swiftPart.getOnPlaybackProgressUpdated();
      return __result;
    }
    inline void setOnPlaybackProgressUpdated(const std::function<void(const PlaybackProgressUpdatedEvent& /* data */)>& onPlaybackProgressUpdated) noexcept override {
      _swiftPart.setOnPlaybackProgressUpdated(onPlaybackProgressUpdated);
    }
    inline std::function<void(const PlaybackQueueEndedEvent& /* data */)> getOnPlaybackQueueEnded() noexcept override {
      auto __result = _swiftPart.getOnPlaybackQueueEnded();
      return __result;
    }
    inline void setOnPlaybackQueueEnded(const std::function<void(const PlaybackQueueEndedEvent& /* data */)>& onPlaybackQueueEnded) noexcept override {
      _swiftPart.setOnPlaybackQueueEnded(onPlaybackQueueEnded);
    }
    inline std::function<void(const std::vector<Track>& /* queue */)> getOnPlaybackQueueChanged() noexcept override {
      auto __result = _swiftPart.getOnPlaybackQueueChanged();
      return __result;
    }
    inline void setOnPlaybackQueueChanged(const std::function<void(const std::vector<Track>& /* queue */)>& onPlaybackQueueChanged) noexcept override {
      _swiftPart.setOnPlaybackQueueChanged(onPlaybackQueueChanged);
    }
    inline std::function<void(const RepeatModeChangedEvent& /* data */)> getOnPlaybackRepeatModeChanged() noexcept override {
      auto __result = _swiftPart.getOnPlaybackRepeatModeChanged();
      return __result;
    }
    inline void setOnPlaybackRepeatModeChanged(const std::function<void(const RepeatModeChangedEvent& /* data */)>& onPlaybackRepeatModeChanged) noexcept override {
      _swiftPart.setOnPlaybackRepeatModeChanged(onPlaybackRepeatModeChanged);
    }
    inline std::function<void(bool /* enabled */)> getOnPlaybackShuffleModeChanged() noexcept override {
      auto __result = _swiftPart.getOnPlaybackShuffleModeChanged();
      return __result;
    }
    inline void setOnPlaybackShuffleModeChanged(const std::function<void(bool /* enabled */)>& onPlaybackShuffleModeChanged) noexcept override {
      _swiftPart.setOnPlaybackShuffleModeChanged(onPlaybackShuffleModeChanged);
    }
    inline std::function<void(const std::optional<std::variant<nitro::NullType, SleepTimerTime, SleepTimerEndOfTrack>>& /* data */)> getOnSleepTimerChanged() noexcept override {
      auto __result = _swiftPart.getOnSleepTimerChanged();
      return __result;
    }
    inline void setOnSleepTimerChanged(const std::function<void(const std::optional<std::variant<nitro::NullType, SleepTimerTime, SleepTimerEndOfTrack>>& /* data */)>& onSleepTimerChanged) noexcept override {
      _swiftPart.setOnSleepTimerChanged(onSleepTimerChanged);
    }
    inline std::function<void(const Playback& /* data */)> getOnPlaybackChanged() noexcept override {
      auto __result = _swiftPart.getOnPlaybackChanged();
      return __result;
    }
    inline void setOnPlaybackChanged(const std::function<void(const Playback& /* data */)>& onPlaybackChanged) noexcept override {
      _swiftPart.setOnPlaybackChanged(onPlaybackChanged);
    }
    inline std::function<void()> getOnRemoteBookmark() noexcept override {
      auto __result = _swiftPart.getOnRemoteBookmark();
      return __result;
    }
    inline void setOnRemoteBookmark(const std::function<void()>& onRemoteBookmark) noexcept override {
      _swiftPart.setOnRemoteBookmark(onRemoteBookmark);
    }
    inline std::function<void()> getOnRemoteDislike() noexcept override {
      auto __result = _swiftPart.getOnRemoteDislike();
      return __result;
    }
    inline void setOnRemoteDislike(const std::function<void()>& onRemoteDislike) noexcept override {
      _swiftPart.setOnRemoteDislike(onRemoteDislike);
    }
    inline std::function<void(const RemoteJumpBackwardEvent& /* event */)> getOnRemoteJumpBackward() noexcept override {
      auto __result = _swiftPart.getOnRemoteJumpBackward();
      return __result;
    }
    inline void setOnRemoteJumpBackward(const std::function<void(const RemoteJumpBackwardEvent& /* event */)>& onRemoteJumpBackward) noexcept override {
      _swiftPart.setOnRemoteJumpBackward(onRemoteJumpBackward);
    }
    inline std::function<void(const RemoteJumpForwardEvent& /* event */)> getOnRemoteJumpForward() noexcept override {
      auto __result = _swiftPart.getOnRemoteJumpForward();
      return __result;
    }
    inline void setOnRemoteJumpForward(const std::function<void(const RemoteJumpForwardEvent& /* event */)>& onRemoteJumpForward) noexcept override {
      _swiftPart.setOnRemoteJumpForward(onRemoteJumpForward);
    }
    inline std::function<void()> getOnRemoteLike() noexcept override {
      auto __result = _swiftPart.getOnRemoteLike();
      return __result;
    }
    inline void setOnRemoteLike(const std::function<void()>& onRemoteLike) noexcept override {
      _swiftPart.setOnRemoteLike(onRemoteLike);
    }
    inline std::function<void()> getOnRemoteNext() noexcept override {
      auto __result = _swiftPart.getOnRemoteNext();
      return __result;
    }
    inline void setOnRemoteNext(const std::function<void()>& onRemoteNext) noexcept override {
      _swiftPart.setOnRemoteNext(onRemoteNext);
    }
    inline std::function<void()> getOnRemotePause() noexcept override {
      auto __result = _swiftPart.getOnRemotePause();
      return __result;
    }
    inline void setOnRemotePause(const std::function<void()>& onRemotePause) noexcept override {
      _swiftPart.setOnRemotePause(onRemotePause);
    }
    inline std::function<void()> getOnRemotePlay() noexcept override {
      auto __result = _swiftPart.getOnRemotePlay();
      return __result;
    }
    inline void setOnRemotePlay(const std::function<void()>& onRemotePlay) noexcept override {
      _swiftPart.setOnRemotePlay(onRemotePlay);
    }
    inline std::function<void(const RemotePlayIdEvent& /* event */)> getOnRemotePlayId() noexcept override {
      auto __result = _swiftPart.getOnRemotePlayId();
      return __result;
    }
    inline void setOnRemotePlayId(const std::function<void(const RemotePlayIdEvent& /* event */)>& onRemotePlayId) noexcept override {
      _swiftPart.setOnRemotePlayId(onRemotePlayId);
    }
    inline std::function<void(const RemotePlaySearchEvent& /* event */)> getOnRemotePlaySearch() noexcept override {
      auto __result = _swiftPart.getOnRemotePlaySearch();
      return __result;
    }
    inline void setOnRemotePlaySearch(const std::function<void(const RemotePlaySearchEvent& /* event */)>& onRemotePlaySearch) noexcept override {
      _swiftPart.setOnRemotePlaySearch(onRemotePlaySearch);
    }
    inline std::function<void()> getOnRemotePrevious() noexcept override {
      auto __result = _swiftPart.getOnRemotePrevious();
      return __result;
    }
    inline void setOnRemotePrevious(const std::function<void()>& onRemotePrevious) noexcept override {
      _swiftPart.setOnRemotePrevious(onRemotePrevious);
    }
    inline std::function<void(const RemoteSeekEvent& /* event */)> getOnRemoteSeek() noexcept override {
      auto __result = _swiftPart.getOnRemoteSeek();
      return __result;
    }
    inline void setOnRemoteSeek(const std::function<void(const RemoteSeekEvent& /* event */)>& onRemoteSeek) noexcept override {
      _swiftPart.setOnRemoteSeek(onRemoteSeek);
    }
    inline std::function<void(const RemoteSetRatingEvent& /* event */)> getOnRemoteSetRating() noexcept override {
      auto __result = _swiftPart.getOnRemoteSetRating();
      return __result;
    }
    inline void setOnRemoteSetRating(const std::function<void(const RemoteSetRatingEvent& /* event */)>& onRemoteSetRating) noexcept override {
      _swiftPart.setOnRemoteSetRating(onRemoteSetRating);
    }
    inline std::function<void(const RemoteSkipEvent& /* event */)> getOnRemoteSkip() noexcept override {
      auto __result = _swiftPart.getOnRemoteSkip();
      return __result;
    }
    inline void setOnRemoteSkip(const std::function<void(const RemoteSkipEvent& /* event */)>& onRemoteSkip) noexcept override {
      _swiftPart.setOnRemoteSkip(onRemoteSkip);
    }
    inline std::function<void()> getOnRemoteStop() noexcept override {
      auto __result = _swiftPart.getOnRemoteStop();
      return __result;
    }
    inline void setOnRemoteStop(const std::function<void()>& onRemoteStop) noexcept override {
      _swiftPart.setOnRemoteStop(onRemoteStop);
    }
    inline std::function<void(const Options& /* event */)> getOnOptionsChanged() noexcept override {
      auto __result = _swiftPart.getOnOptionsChanged();
      return __result;
    }
    inline void setOnOptionsChanged(const std::function<void(const Options& /* event */)>& onOptionsChanged) noexcept override {
      _swiftPart.setOnOptionsChanged(onOptionsChanged);
    }
    inline std::function<void(const FavoriteChangedEvent& /* event */)> getOnFavoriteChanged() noexcept override {
      auto __result = _swiftPart.getOnFavoriteChanged();
      return __result;
    }
    inline void setOnFavoriteChanged(const std::function<void(const FavoriteChangedEvent& /* event */)>& onFavoriteChanged) noexcept override {
      _swiftPart.setOnFavoriteChanged(onFavoriteChanged);
    }
    inline std::function<void(const NowPlayingMetadata& /* metadata */)> getOnNowPlayingChanged() noexcept override {
      auto __result = _swiftPart.getOnNowPlayingChanged();
      return __result;
    }
    inline void setOnNowPlayingChanged(const std::function<void(const NowPlayingMetadata& /* metadata */)>& onNowPlayingChanged) noexcept override {
      _swiftPart.setOnNowPlayingChanged(onNowPlayingChanged);
    }
    inline std::optional<std::function<void()>> getHandleRemoteBookmark() noexcept override {
      auto __result = _swiftPart.getHandleRemoteBookmark();
      return __result;
    }
    inline void setHandleRemoteBookmark(const std::optional<std::function<void()>>& handleRemoteBookmark) noexcept override {
      _swiftPart.setHandleRemoteBookmark(handleRemoteBookmark);
    }
    inline std::optional<std::function<void()>> getHandleRemoteDislike() noexcept override {
      auto __result = _swiftPart.getHandleRemoteDislike();
      return __result;
    }
    inline void setHandleRemoteDislike(const std::optional<std::function<void()>>& handleRemoteDislike) noexcept override {
      _swiftPart.setHandleRemoteDislike(handleRemoteDislike);
    }
    inline std::optional<std::function<void(const RemoteJumpBackwardEvent& /* event */)>> getHandleRemoteJumpBackward() noexcept override {
      auto __result = _swiftPart.getHandleRemoteJumpBackward();
      return __result;
    }
    inline void setHandleRemoteJumpBackward(const std::optional<std::function<void(const RemoteJumpBackwardEvent& /* event */)>>& handleRemoteJumpBackward) noexcept override {
      _swiftPart.setHandleRemoteJumpBackward(handleRemoteJumpBackward);
    }
    inline std::optional<std::function<void(const RemoteJumpForwardEvent& /* event */)>> getHandleRemoteJumpForward() noexcept override {
      auto __result = _swiftPart.getHandleRemoteJumpForward();
      return __result;
    }
    inline void setHandleRemoteJumpForward(const std::optional<std::function<void(const RemoteJumpForwardEvent& /* event */)>>& handleRemoteJumpForward) noexcept override {
      _swiftPart.setHandleRemoteJumpForward(handleRemoteJumpForward);
    }
    inline std::optional<std::function<void()>> getHandleRemoteLike() noexcept override {
      auto __result = _swiftPart.getHandleRemoteLike();
      return __result;
    }
    inline void setHandleRemoteLike(const std::optional<std::function<void()>>& handleRemoteLike) noexcept override {
      _swiftPart.setHandleRemoteLike(handleRemoteLike);
    }
    inline std::optional<std::function<void()>> getHandleRemoteNext() noexcept override {
      auto __result = _swiftPart.getHandleRemoteNext();
      return __result;
    }
    inline void setHandleRemoteNext(const std::optional<std::function<void()>>& handleRemoteNext) noexcept override {
      _swiftPart.setHandleRemoteNext(handleRemoteNext);
    }
    inline std::optional<std::function<void()>> getHandleRemotePause() noexcept override {
      auto __result = _swiftPart.getHandleRemotePause();
      return __result;
    }
    inline void setHandleRemotePause(const std::optional<std::function<void()>>& handleRemotePause) noexcept override {
      _swiftPart.setHandleRemotePause(handleRemotePause);
    }
    inline std::optional<std::function<void()>> getHandleRemotePlay() noexcept override {
      auto __result = _swiftPart.getHandleRemotePlay();
      return __result;
    }
    inline void setHandleRemotePlay(const std::optional<std::function<void()>>& handleRemotePlay) noexcept override {
      _swiftPart.setHandleRemotePlay(handleRemotePlay);
    }
    inline std::optional<std::function<void(const RemotePlayIdEvent& /* event */)>> getHandleRemotePlayId() noexcept override {
      auto __result = _swiftPart.getHandleRemotePlayId();
      return __result;
    }
    inline void setHandleRemotePlayId(const std::optional<std::function<void(const RemotePlayIdEvent& /* event */)>>& handleRemotePlayId) noexcept override {
      _swiftPart.setHandleRemotePlayId(handleRemotePlayId);
    }
    inline std::optional<std::function<void(const RemotePlaySearchEvent& /* event */)>> getHandleRemotePlaySearch() noexcept override {
      auto __result = _swiftPart.getHandleRemotePlaySearch();
      return __result;
    }
    inline void setHandleRemotePlaySearch(const std::optional<std::function<void(const RemotePlaySearchEvent& /* event */)>>& handleRemotePlaySearch) noexcept override {
      _swiftPart.setHandleRemotePlaySearch(handleRemotePlaySearch);
    }
    inline std::optional<std::function<void()>> getHandleRemotePrevious() noexcept override {
      auto __result = _swiftPart.getHandleRemotePrevious();
      return __result;
    }
    inline void setHandleRemotePrevious(const std::optional<std::function<void()>>& handleRemotePrevious) noexcept override {
      _swiftPart.setHandleRemotePrevious(handleRemotePrevious);
    }
    inline std::optional<std::function<void(const RemoteSeekEvent& /* event */)>> getHandleRemoteSeek() noexcept override {
      auto __result = _swiftPart.getHandleRemoteSeek();
      return __result;
    }
    inline void setHandleRemoteSeek(const std::optional<std::function<void(const RemoteSeekEvent& /* event */)>>& handleRemoteSeek) noexcept override {
      _swiftPart.setHandleRemoteSeek(handleRemoteSeek);
    }
    inline std::optional<std::function<void()>> getHandleRemoteSkip() noexcept override {
      auto __result = _swiftPart.getHandleRemoteSkip();
      return __result;
    }
    inline void setHandleRemoteSkip(const std::optional<std::function<void()>>& handleRemoteSkip) noexcept override {
      _swiftPart.setHandleRemoteSkip(handleRemoteSkip);
    }
    inline std::optional<std::function<void()>> getHandleRemoteStop() noexcept override {
      auto __result = _swiftPart.getHandleRemoteStop();
      return __result;
    }
    inline void setHandleRemoteStop(const std::optional<std::function<void()>>& handleRemoteStop) noexcept override {
      _swiftPart.setHandleRemoteStop(handleRemoteStop);
    }
    inline std::function<void(bool /* online */)> getOnOnlineChanged() noexcept override {
      auto __result = _swiftPart.getOnOnlineChanged();
      return __result;
    }
    inline void setOnOnlineChanged(const std::function<void(bool /* online */)>& onOnlineChanged) noexcept override {
      _swiftPart.setOnOnlineChanged(onOnlineChanged);
    }
    inline std::function<void(const EqualizerSettings& /* settings */)> getOnEqualizerChanged() noexcept override {
      auto __result = _swiftPart.getOnEqualizerChanged();
      return __result;
    }
    inline void setOnEqualizerChanged(const std::function<void(const EqualizerSettings& /* settings */)>& onEqualizerChanged) noexcept override {
      _swiftPart.setOnEqualizerChanged(onEqualizerChanged);
    }
    inline std::function<void(const BatteryWarningPendingChangedEvent& /* event */)> getOnBatteryWarningPendingChanged() noexcept override {
      auto __result = _swiftPart.getOnBatteryWarningPendingChanged();
      return __result;
    }
    inline void setOnBatteryWarningPendingChanged(const std::function<void(const BatteryWarningPendingChangedEvent& /* event */)>& onBatteryWarningPendingChanged) noexcept override {
      _swiftPart.setOnBatteryWarningPendingChanged(onBatteryWarningPendingChanged);
    }
    inline std::function<void(const BatteryOptimizationStatusChangedEvent& /* event */)> getOnBatteryOptimizationStatusChanged() noexcept override {
      auto __result = _swiftPart.getOnBatteryOptimizationStatusChanged();
      return __result;
    }
    inline void setOnBatteryOptimizationStatusChanged(const std::function<void(const BatteryOptimizationStatusChangedEvent& /* event */)>& onBatteryOptimizationStatusChanged) noexcept override {
      _swiftPart.setOnBatteryOptimizationStatusChanged(onBatteryOptimizationStatusChanged);
    }

  public:
    // Methods
    inline void navigatePath(const std::string& path) override {
      auto __result = _swiftPart.navigatePath(path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void navigateTrack(const Track& track) override {
      auto __result = _swiftPart.navigateTrack(std::forward<decltype(track)>(track));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::shared_ptr<Promise<std::vector<Track>>> onSearch(const std::string& query) override {
      auto __result = _swiftPart.onSearch(query);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::optional<ResolvedTrack> getContent() override {
      auto __result = _swiftPart.getContent();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::optional<NavigationError> getNavigationError() override {
      auto __result = _swiftPart.getNavigationError();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::optional<FormattedNavigationError> getFormattedNavigationError() override {
      auto __result = _swiftPart.getFormattedNavigationError();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void notifyContentChanged(const std::string& path) override {
      auto __result = _swiftPart.notifyContentChanged(path);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setFavorites(const std::vector<std::string>& favorites) override {
      auto __result = _swiftPart.setFavorites(favorites);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::shared_ptr<Promise<void>> setupPlayer(const PartialSetupPlayerOptions& options) override {
      auto __result = _swiftPart.setupPlayer(std::forward<decltype(options)>(options));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void updateOptions(const NativeUpdateOptions& options) override {
      auto __result = _swiftPart.updateOptions(std::forward<decltype(options)>(options));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline UpdateOptions getOptions() override {
      auto __result = _swiftPart.getOptions();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void load(const Track& track) override {
      auto __result = _swiftPart.load(std::forward<decltype(track)>(track));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void reset() override {
      auto __result = _swiftPart.reset();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void play() override {
      auto __result = _swiftPart.play();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void pause() override {
      auto __result = _swiftPart.pause();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void togglePlayback() override {
      auto __result = _swiftPart.togglePlayback();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void stop() override {
      auto __result = _swiftPart.stop();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setPlayWhenReady(bool playWhenReady) override {
      auto __result = _swiftPart.setPlayWhenReady(std::forward<decltype(playWhenReady)>(playWhenReady));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline bool getPlayWhenReady() override {
      auto __result = _swiftPart.getPlayWhenReady();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void seekTo(double position) override {
      auto __result = _swiftPart.seekTo(std::forward<decltype(position)>(position));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void seekBy(double offset) override {
      auto __result = _swiftPart.seekBy(std::forward<decltype(offset)>(offset));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setVolume(double level) override {
      auto __result = _swiftPart.setVolume(std::forward<decltype(level)>(level));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline double getVolume() override {
      auto __result = _swiftPart.getVolume();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void setRate(double rate) override {
      auto __result = _swiftPart.setRate(std::forward<decltype(rate)>(rate));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline double getRate() override {
      auto __result = _swiftPart.getRate();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline Progress getProgress() override {
      auto __result = _swiftPart.getProgress();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline Playback getPlayback() override {
      auto __result = _swiftPart.getPlayback();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline PlayingState getPlayingState() override {
      auto __result = _swiftPart.getPlayingState();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline RepeatMode getRepeatMode() override {
      auto __result = _swiftPart.getRepeatMode();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void setRepeatMode(RepeatMode mode) override {
      auto __result = _swiftPart.setRepeatMode(static_cast<int>(mode));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline bool getShuffleEnabled() override {
      auto __result = _swiftPart.getShuffleEnabled();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void setShuffleEnabled(bool enabled) override {
      auto __result = _swiftPart.setShuffleEnabled(std::forward<decltype(enabled)>(enabled));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::optional<PlaybackError> getPlaybackError() override {
      auto __result = _swiftPart.getPlaybackError();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void retry() override {
      auto __result = _swiftPart.retry();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::variant<nitro::NullType, SleepTimerTime, SleepTimerEndOfTrack> getSleepTimer() override {
      auto __result = _swiftPart.getSleepTimer();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void setSleepTimer(double seconds) override {
      auto __result = _swiftPart.setSleepTimer(std::forward<decltype(seconds)>(seconds));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setSleepTimerToEndOfTrack() override {
      auto __result = _swiftPart.setSleepTimerToEndOfTrack();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline bool clearSleepTimer() override {
      auto __result = _swiftPart.clearSleepTimer();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void add(const std::vector<Track>& tracks, std::optional<double> insertBeforeIndex) override {
      auto __result = _swiftPart.add(tracks, insertBeforeIndex);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void move(double fromIndex, double toIndex) override {
      auto __result = _swiftPart.move(std::forward<decltype(fromIndex)>(fromIndex), std::forward<decltype(toIndex)>(toIndex));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void remove(const std::vector<double>& indexes) override {
      auto __result = _swiftPart.remove(indexes);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void removeUpcomingTracks() override {
      auto __result = _swiftPart.removeUpcomingTracks();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void skip(double index, std::optional<double> initialPosition) override {
      auto __result = _swiftPart.skip(std::forward<decltype(index)>(index), initialPosition);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void skipToNext(std::optional<double> initialPosition) override {
      auto __result = _swiftPart.skipToNext(initialPosition);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void skipToPrevious(std::optional<double> initialPosition) override {
      auto __result = _swiftPart.skipToPrevious(initialPosition);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setActiveTrackFavorited(bool favorited) override {
      auto __result = _swiftPart.setActiveTrackFavorited(std::forward<decltype(favorited)>(favorited));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void toggleActiveTrackFavorited() override {
      auto __result = _swiftPart.toggleActiveTrackFavorited();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setQueue(const std::vector<Track>& tracks, std::optional<double> startIndex, std::optional<double> startPositionMs) override {
      auto __result = _swiftPart.setQueue(tracks, startIndex, startPositionMs);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::vector<Track> getQueue() override {
      auto __result = _swiftPart.getQueue();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::optional<Track> getTrack(double index) override {
      auto __result = _swiftPart.getTrack(std::forward<decltype(index)>(index));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::optional<double> getActiveTrackIndex() override {
      auto __result = _swiftPart.getActiveTrackIndex();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::optional<Track> getActiveTrack() override {
      auto __result = _swiftPart.getActiveTrack();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void updateNowPlaying(const std::optional<NowPlayingUpdate>& update) override {
      auto __result = _swiftPart.updateNowPlaying(update);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline std::optional<NowPlayingMetadata> getNowPlaying() override {
      auto __result = _swiftPart.getNowPlaying();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline bool getOnline() override {
      auto __result = _swiftPart.getOnline();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::optional<EqualizerSettings> getEqualizerSettings() override {
      auto __result = _swiftPart.getEqualizerSettings();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void setEqualizerEnabled(bool enabled) override {
      auto __result = _swiftPart.setEqualizerEnabled(std::forward<decltype(enabled)>(enabled));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setEqualizerPreset(const std::string& preset) override {
      auto __result = _swiftPart.setEqualizerPreset(preset);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setEqualizerLevels(const std::vector<double>& levels) override {
      auto __result = _swiftPart.setEqualizerLevels(levels);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline bool getBatteryWarningPending() override {
      auto __result = _swiftPart.getBatteryWarningPending();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline BatteryOptimizationStatus getBatteryOptimizationStatus() override {
      auto __result = _swiftPart.getBatteryOptimizationStatus();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline void dismissBatteryWarning() override {
      auto __result = _swiftPart.dismissBatteryWarning();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void openBatterySettings() override {
      auto __result = _swiftPart.openBatterySettings();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }

  private:
    AudioBrowser::HybridAudioBrowserSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::audiobrowser
