///
/// JHybridAudioBrowserSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridAudioBrowserSpec.hpp"

// Forward declaration of `Progress` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct Progress; }
// Forward declaration of `PlaybackState` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackState; }
// Forward declaration of `State` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class State; }
// Forward declaration of `PlaybackError` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlaybackError; }
// Forward declaration of `PlayingState` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlayingState; }
// Forward declaration of `RepeatMode` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class RepeatMode; }
// Forward declaration of `Track` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct Track; }
// Forward declaration of `TrackType` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class TrackType; }
// Forward declaration of `PitchAlgorithm` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class PitchAlgorithm; }
// Forward declaration of `RatingType` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class RatingType; }
// Forward declaration of `PlayerOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct PlayerOptions; }
// Forward declaration of `AndroidPlayerOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct AndroidPlayerOptions; }
// Forward declaration of `AndroidAudioOffloadSettings` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct AndroidAudioOffloadSettings; }
// Forward declaration of `AndroidAudioContentType` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class AndroidAudioContentType; }
// Forward declaration of `IOSPlayerOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { struct IOSPlayerOptions; }
// Forward declaration of `IOSCategory` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class IOSCategory; }
// Forward declaration of `IOSCategoryMode` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class IOSCategoryMode; }
// Forward declaration of `IOSCategoryOptions` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class IOSCategoryOptions; }
// Forward declaration of `IOSCategoryPolicy` to properly resolve imports.
namespace margelo::nitro::audiobrowser { enum class IOSCategoryPolicy; }

#include <NitroModules/Promise.hpp>
#include <NitroModules/JPromise.hpp>
#include "Progress.hpp"
#include "JProgress.hpp"
#include "PlaybackState.hpp"
#include "JPlaybackState.hpp"
#include "State.hpp"
#include "JState.hpp"
#include "PlaybackError.hpp"
#include <optional>
#include "JPlaybackError.hpp"
#include <string>
#include "PlayingState.hpp"
#include "JPlayingState.hpp"
#include "RepeatMode.hpp"
#include "JRepeatMode.hpp"
#include "Track.hpp"
#include <vector>
#include "JTrack.hpp"
#include "TrackType.hpp"
#include "JTrackType.hpp"
#include "PitchAlgorithm.hpp"
#include "JPitchAlgorithm.hpp"
#include "RatingType.hpp"
#include "JRatingType.hpp"
#include "PlayerOptions.hpp"
#include "JPlayerOptions.hpp"
#include "AndroidPlayerOptions.hpp"
#include "JAndroidPlayerOptions.hpp"
#include "AndroidAudioOffloadSettings.hpp"
#include <variant>
#include "JVariant_Boolean_AndroidAudioOffloadSettings.hpp"
#include "JAndroidAudioOffloadSettings.hpp"
#include "AndroidAudioContentType.hpp"
#include "JAndroidAudioContentType.hpp"
#include "IOSPlayerOptions.hpp"
#include "JIOSPlayerOptions.hpp"
#include "IOSCategory.hpp"
#include "JIOSCategory.hpp"
#include "IOSCategoryMode.hpp"
#include "JIOSCategoryMode.hpp"
#include "IOSCategoryOptions.hpp"
#include "JIOSCategoryOptions.hpp"
#include "IOSCategoryPolicy.hpp"
#include "JIOSCategoryPolicy.hpp"

namespace margelo::nitro::audiobrowser {

  jni::local_ref<JHybridAudioBrowserSpec::jhybriddata> JHybridAudioBrowserSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridAudioBrowserSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridAudioBrowserSpec::initHybrid),
    });
  }

  size_t JHybridAudioBrowserSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridAudioBrowserSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  // Properties
  

  // Methods
  std::shared_ptr<Promise<void>> JHybridAudioBrowserSpec::setupPlayer(const PlayerOptions& options) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JPlayerOptions> /* options */)>("setupPlayer");
    auto __result = method(_javaPart, JPlayerOptions::fromCpp(options));
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  void JHybridAudioBrowserSpec::load(const Track& track) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JTrack> /* track */)>("load");
    method(_javaPart, JTrack::fromCpp(track));
  }
  void JHybridAudioBrowserSpec::reset() {
    static const auto method = javaClassStatic()->getMethod<void()>("reset");
    method(_javaPart);
  }
  void JHybridAudioBrowserSpec::play() {
    static const auto method = javaClassStatic()->getMethod<void()>("play");
    method(_javaPart);
  }
  void JHybridAudioBrowserSpec::pause() {
    static const auto method = javaClassStatic()->getMethod<void()>("pause");
    method(_javaPart);
  }
  void JHybridAudioBrowserSpec::togglePlayback() {
    static const auto method = javaClassStatic()->getMethod<void()>("togglePlayback");
    method(_javaPart);
  }
  void JHybridAudioBrowserSpec::stop() {
    static const auto method = javaClassStatic()->getMethod<void()>("stop");
    method(_javaPart);
  }
  void JHybridAudioBrowserSpec::setPlayWhenReady(bool playWhenReady) {
    static const auto method = javaClassStatic()->getMethod<void(jboolean /* playWhenReady */)>("setPlayWhenReady");
    method(_javaPart, playWhenReady);
  }
  bool JHybridAudioBrowserSpec::getPlayWhenReady() {
    static const auto method = javaClassStatic()->getMethod<jboolean()>("getPlayWhenReady");
    auto __result = method(_javaPart);
    return static_cast<bool>(__result);
  }
  void JHybridAudioBrowserSpec::seekTo(double position) {
    static const auto method = javaClassStatic()->getMethod<void(double /* position */)>("seekTo");
    method(_javaPart, position);
  }
  void JHybridAudioBrowserSpec::seekBy(double offset) {
    static const auto method = javaClassStatic()->getMethod<void(double /* offset */)>("seekBy");
    method(_javaPart, offset);
  }
  void JHybridAudioBrowserSpec::setVolume(double level) {
    static const auto method = javaClassStatic()->getMethod<void(double /* level */)>("setVolume");
    method(_javaPart, level);
  }
  double JHybridAudioBrowserSpec::getVolume() {
    static const auto method = javaClassStatic()->getMethod<double()>("getVolume");
    auto __result = method(_javaPart);
    return __result;
  }
  void JHybridAudioBrowserSpec::setRate(double rate) {
    static const auto method = javaClassStatic()->getMethod<void(double /* rate */)>("setRate");
    method(_javaPart, rate);
  }
  double JHybridAudioBrowserSpec::getRate() {
    static const auto method = javaClassStatic()->getMethod<double()>("getRate");
    auto __result = method(_javaPart);
    return __result;
  }
  Progress JHybridAudioBrowserSpec::getProgress() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JProgress>()>("getProgress");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  PlaybackState JHybridAudioBrowserSpec::getPlaybackState() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPlaybackState>()>("getPlaybackState");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  PlayingState JHybridAudioBrowserSpec::getPlayingState() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPlayingState>()>("getPlayingState");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  RepeatMode JHybridAudioBrowserSpec::getRepeatMode() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JRepeatMode>()>("getRepeatMode");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  void JHybridAudioBrowserSpec::setRepeatMode(RepeatMode mode) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JRepeatMode> /* mode */)>("setRepeatMode");
    method(_javaPart, JRepeatMode::fromCpp(mode));
  }
  std::optional<PlaybackError> JHybridAudioBrowserSpec::getPlaybackError() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPlaybackError>()>("getPlaybackError");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridAudioBrowserSpec::retry() {
    static const auto method = javaClassStatic()->getMethod<void()>("retry");
    method(_javaPart);
  }
  void JHybridAudioBrowserSpec::add(const std::vector<Track>& tracks, std::optional<double> insertBeforeIndex) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JTrack>> /* tracks */, jni::alias_ref<jni::JDouble> /* insertBeforeIndex */)>("add");
    method(_javaPart, [&]() {
      size_t __size = tracks.size();
      jni::local_ref<jni::JArrayClass<JTrack>> __array = jni::JArrayClass<JTrack>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = tracks[__i];
        __array->setElement(__i, *JTrack::fromCpp(__element));
      }
      return __array;
    }(), insertBeforeIndex.has_value() ? jni::JDouble::valueOf(insertBeforeIndex.value()) : nullptr);
  }
  void JHybridAudioBrowserSpec::move(double fromIndex, double toIndex) {
    static const auto method = javaClassStatic()->getMethod<void(double /* fromIndex */, double /* toIndex */)>("move");
    method(_javaPart, fromIndex, toIndex);
  }
  void JHybridAudioBrowserSpec::remove(const std::vector<double>& indexes) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* indexes */)>("remove");
    method(_javaPart, [&]() {
      size_t __size = indexes.size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, indexes.data());
      return __array;
    }());
  }
  void JHybridAudioBrowserSpec::removeUpcomingTracks() {
    static const auto method = javaClassStatic()->getMethod<void()>("removeUpcomingTracks");
    method(_javaPart);
  }
  void JHybridAudioBrowserSpec::skip(double index, std::optional<double> initialPosition) {
    static const auto method = javaClassStatic()->getMethod<void(double /* index */, jni::alias_ref<jni::JDouble> /* initialPosition */)>("skip");
    method(_javaPart, index, initialPosition.has_value() ? jni::JDouble::valueOf(initialPosition.value()) : nullptr);
  }
  void JHybridAudioBrowserSpec::skipToNext(std::optional<double> initialPosition) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* initialPosition */)>("skipToNext");
    method(_javaPart, initialPosition.has_value() ? jni::JDouble::valueOf(initialPosition.value()) : nullptr);
  }
  void JHybridAudioBrowserSpec::skipToPrevious(std::optional<double> initialPosition) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* initialPosition */)>("skipToPrevious");
    method(_javaPart, initialPosition.has_value() ? jni::JDouble::valueOf(initialPosition.value()) : nullptr);
  }
  void JHybridAudioBrowserSpec::setQueue(const std::vector<Track>& tracks) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayClass<JTrack>> /* tracks */)>("setQueue");
    method(_javaPart, [&]() {
      size_t __size = tracks.size();
      jni::local_ref<jni::JArrayClass<JTrack>> __array = jni::JArrayClass<JTrack>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = tracks[__i];
        __array->setElement(__i, *JTrack::fromCpp(__element));
      }
      return __array;
    }());
  }
  std::vector<Track> JHybridAudioBrowserSpec::getQueue() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JTrack>>()>("getQueue");
    auto __result = method(_javaPart);
    return [&]() {
      size_t __size = __result->size();
      std::vector<Track> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(__element->toCpp());
      }
      return __vector;
    }();
  }
  std::optional<Track> JHybridAudioBrowserSpec::getTrack(double index) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JTrack>(double /* index */)>("getTrack");
    auto __result = method(_javaPart, index);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  std::optional<double> JHybridAudioBrowserSpec::getActiveTrackIndex() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getActiveTrackIndex");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  std::optional<Track> JHybridAudioBrowserSpec::getActiveTrack() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JTrack>()>("getActiveTrack");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridAudioBrowserSpec::acquireWakeLock() {
    static const auto method = javaClassStatic()->getMethod<void()>("acquireWakeLock");
    method(_javaPart);
  }
  void JHybridAudioBrowserSpec::abandonWakeLock() {
    static const auto method = javaClassStatic()->getMethod<void()>("abandonWakeLock");
    method(_javaPart);
  }

} // namespace margelo::nitro::audiobrowser
